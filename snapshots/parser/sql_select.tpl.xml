<parser-snapshots>
    <!-- Parse SELECT NULL literal -->
    <parser-snapshot name="select_null">
        <input>
            select null 
        </input>
    </parser-snapshot>
    <!-- Parse integer constant -->
    <parser-snapshot name="select_iconst_1">
        <input>
            select 1
        </input>
    </parser-snapshot>
    <!-- Parse float constant in scientific notation -->
    <parser-snapshot name="select_fconst_1e04">
        <input>
            select 1e-04
        </input>
    </parser-snapshot>
    <!-- Parse bit string constant -->
    <parser-snapshot name="select_bconst_b1010">
        <input>
            select b'1010'
        </input>
    </parser-snapshot>
    <!-- Parse unquoted string (identifier) -->
    <parser-snapshot name="select_sconst_string">
        <input>
            select string
        </input>
    </parser-snapshot>
    <!-- Parse string with Latin-1 characters -->
    <parser-snapshot name="select_sconst_string_latin1">
        <input>
            select Ã¤Ã¶Ã¼
        </input>
    </parser-snapshot>
    <!-- Parse string with Unicode plane 1 character (emoji) -->
    <parser-snapshot name="select_sconst_string_unicode_plane1">
        <input>
            select ðŸ“ˆ
        </input>
    </parser-snapshot>
    <!-- Parse comparison expression -->
    <parser-snapshot name="select_1_gt_2">
        <input>
            select 1 > 2
        </input>
    </parser-snapshot>
    <!-- Parse single-quoted string literal -->
    <parser-snapshot name="select_sconst_quotes">
        <input>
            select 'foo'
        </input>
    </parser-snapshot>
    <!-- Parse string with escaped single quote -->
    <parser-snapshot name="select_sconst_quotes_nested_quote">
        <input>
            select '''foo'''
        </input>
    </parser-snapshot>
    <!-- Parse string containing double-quoted substring -->
    <parser-snapshot name="select_sconst_quotes_nested_dquote">
        <input>
            select '"foo"'
        </input>
    </parser-snapshot>
    <!-- Parse literal followed by quoted identifier -->
    <parser-snapshot name="select_iconst_1_ident">
        <input>
            select 1 "foo"
        </input>
    </parser-snapshot>
    <!-- Parse C-style block comment -->
    <parser-snapshot name="comments_cstyle">
        <input>
            /* foo */
        </input>
    </parser-snapshot>
    <!-- Parse nested C-style comments -->
    <parser-snapshot name="comments_cstyle_nested">
        <input>
            /* foo /* bar */ */
        </input>
    </parser-snapshot>
    <!-- Parse select list with multiple expressions -->
    <parser-snapshot name="select_iconst_list">
        <input>
            select 1, 2
        </input>
    </parser-snapshot>
    <!-- Parse FROM with single table reference -->
    <parser-snapshot name="select_from_1rel">
        <input>
            select a from b
        </input>
    </parser-snapshot>
    <!-- Parse FROM with schema-qualified table (b.c) -->
    <parser-snapshot name="select_from_1rel_indirect1">
        <input>
            select a from b.c
        </input>
    </parser-snapshot>
    <!-- Parse FROM with ONLY before schema-qualified table -->
    <parser-snapshot name="select_from_1rel_indirect1_noinherit">
        <input>
            select a from only b.c
        </input>
    </parser-snapshot>
    <!-- Parse FROM with schema-qualified table and AS alias -->
    <parser-snapshot name="select_from_1rel_indirect1_alias">
        <input>
            select a from b.c as d
        </input>
    </parser-snapshot>
    <!-- Parse FROM with two table references (comma join) -->
    <parser-snapshot name="select_from_2rel">
        <input>
            select a from b, c
        </input>
    </parser-snapshot>
    <!-- Parse SELECT INTO with multiple tables -->
    <parser-snapshot name="select_from_into_2rel">
        <input>
            select a into b from c, d
        </input>
    </parser-snapshot>
    <!-- Parse GROUP BY with position reference -->
    <parser-snapshot name="select_from_1rel_group1">
        <input>
            select a from b group by 1
        </input>
    </parser-snapshot>
    <!-- Parse named window with empty definition -->
    <parser-snapshot name="select_from_1rel_window_empty">
        <input>
            select a from b window c as ()
        </input>
    </parser-snapshot>
    <!-- Parse window with PARTITION BY -->
    <parser-snapshot name="select_from_1rel_window_partition1">
        <input>
            select a from b window c as (partition by d)
        </input>
    </parser-snapshot>
    <!-- Parse window with ROWS BETWEEN unbounded frame -->
    <parser-snapshot name="select_from_1rel_window_partition1_rows_unbounded">
        <input>
            select a from b
            window c as (partition by d rows between unbounded preceding and unbounded following)
        </input>
    </parser-snapshot>
    <!-- Parse window with ROWS 1 PRECEDING AND CURRENT ROW -->
    <parser-snapshot name="select_from_1rel_window_partition1_rows_1preceding_current">
        <input>
            select a from b
            window c as (partition by d rows between 1 preceding and current row)
        </input>
    </parser-snapshot>
    <!-- Parse multiple named window definitions -->
    <parser-snapshot name="select_from_1rel_2windows">
        <input>
            select a from b
            window c as (partition by d range between current row and 1 following),
                    e as (partition by f)
        </input>
    </parser-snapshot>
    <!-- Parse SELECT DISTINCT -->
    <parser-snapshot name="select_distinct_from_1rel">
        <input>
            select distinct a from b
        </input>
    </parser-snapshot>
    <!-- Parse SELECT DISTINCT ON (expr) -->
    <parser-snapshot name="select_distinct_on_from_1rel">
        <input>
            select distinct on (a) a from b
        </input>
    </parser-snapshot>
    <!-- Parse SELECT ALL (column named "all") -->
    <parser-snapshot name="select_all_from_1rel">
        <input>
            select all from b
        </input>
    </parser-snapshot>
    <!-- Parse VALUES with single row -->
    <parser-snapshot name="values_1">
        <input>
            values (1)
        </input>
    </parser-snapshot>
    <!-- Parse VALUES with multiple rows -->
    <parser-snapshot name="values_1_2">
        <input>
            values (1), (2);
        </input>
    </parser-snapshot>
    <!-- Parse VALUES with multiple columns per row -->
    <parser-snapshot name="values_12_34">
        <input>
            values (1, 2), (3, 4)
        </input>
    </parser-snapshot>
    <!-- Parse TABLE table_ref (shorthand for SELECT * FROM) -->
    <parser-snapshot name="table_a">
        <input>
            TABLE a
        </input>
    </parser-snapshot>
    <!-- Parse UNION of two selects -->
    <parser-snapshot name="union_select1_select2">
        <input>
            SELECT 1 UNION SELECT 2
        </input>
    </parser-snapshot>
    <!-- Parse UNION ALL -->
    <parser-snapshot name="union_all_select1_select2">
        <input>
            SELECT 1 UNION ALL SELECT 2
        </input>
    </parser-snapshot>
    <!-- Parse UNION DISTINCT -->
    <parser-snapshot name="union_distinct_select1_select2">
        <input>
            SELECT 1 UNION DISTINCT SELECT 2
        </input>
    </parser-snapshot>
    <!-- Parse INTERSECT -->
    <parser-snapshot name="intersect_select1_select2">
        <input>
            SELECT 1 INTERSECT SELECT 2
        </input>
    </parser-snapshot>
    <!-- Parse WITH single CTE -->
    <parser-snapshot name="with_1cte_select2">
        <input>
            WITH a AS (SELECT 1) SELECT 2
        </input>
    </parser-snapshot>
    <!-- Parse WITH multiple CTEs -->
    <parser-snapshot name="with_2ctes_select3">
        <input>
            WITH a AS (SELECT 1), b AS (SELECT 2) SELECT 3
        </input>
    </parser-snapshot>
    <!-- Parse WITH RECURSIVE and multiple CTEs -->
    <parser-snapshot name="with_recursive_2ctes_select3">
        <input>
            WITH RECURSIVE a AS (SELECT 1), b AS (SELECT 2) SELECT 3
        </input>
    </parser-snapshot>
    <!-- Parse ORDER BY single column -->
    <parser-snapshot name="select_a_orderby_b">
        <input>
            select a order by b
        </input>
    </parser-snapshot>
    <!-- Parse ORDER BY multiple columns -->
    <parser-snapshot name="select_a_orderby_b_c">
        <input>
            select a order by b, c
        </input>
    </parser-snapshot>
    <!-- Parse ORDER BY with ASC/DESC -->
    <parser-snapshot name="select_a_orderby_b_c_directions">
        <input>
            select a order by b asc, c desc
        </input>
    </parser-snapshot>
    <!-- Parse ORDER BY with NULLS FIRST/LAST -->
    <parser-snapshot name="select_a_orderby_b_c_directions_nulls">
        <input>
            select a order by b asc nulls first, c desc nulls last
        </input>
    </parser-snapshot>
    <!-- Parse SELECT INTO and subsequent FROM referencing created table -->
    <parser-snapshot name="select_table_ref">
        <input>
            select 1 into b;
            select 1 from b;
        </input>
    </parser-snapshot>
    <!-- Parse join with table aliases and WHERE -->
    <parser-snapshot name="select_table_ref_1">
        <input>
            select * from A a, B b where a.x = b.y
        </input>
    </parser-snapshot>
    <!-- Parse parameter reference in expression ($a + 1) -->
    <parser-snapshot name="select_column_ref_expr_1">
        <input>
            select 1 into b;
            select c from b where c = $a + 1
        </input>
    </parser-snapshot>
    <!-- Parse multiple parameters in WHERE -->
    <parser-snapshot name="select_column_ref_expr_2">
        <input>
            select * into countries_joined from country1_weather c1, country2_weather c2 where c1.month = c2.month and c2.month = $month
        </input>
    </parser-snapshot>
    <!-- Parse set-returning function with column alias -->
    <parser-snapshot name="select_generate_series">
        <input>
            select v into a FROM generate_series(0, 10000) as t(v);
        </input>
    </parser-snapshot>
    <!-- Parse table-valued function in FROM -->
    <parser-snapshot name="select_functable">
        <input>
            select * from somefunc('somearg') foo;
        </input>
    </parser-snapshot>
    <!-- Parse function call with constant argument (no parens around constant) -->
    <parser-snapshot name="select_funcconst_1">
        <input>
            select somefunc 'foo';
        </input>
    </parser-snapshot>
    <!-- Parse function call with parens and trailing constant -->
    <parser-snapshot name="select_funcconst_2">
        <input>
            select somefunc(1) 'foo';
        </input>
    </parser-snapshot>
    <!-- Parse type cast: typename 'value' -->
    <parser-snapshot name="select_const_typename_cast">
        <input>
            select integer '1';
        </input>
    </parser-snapshot>
    <!-- Parse INTERVAL with minute to second range -->
    <parser-snapshot name="select_const_interval_1">
        <input>
            select interval '90' minute to second;
        </input>
    </parser-snapshot>
    <!-- Parse INTERVAL with single unit (hour) -->
    <parser-snapshot name="select_const_interval_2">
        <input>
            select interval '90' hour;
        </input>
    </parser-snapshot>
    <!-- Parse INTERVAL with numeric value and unit -->
    <parser-snapshot name="select_const_interval_3">
        <input>
            select interval 1 hour;
        </input>
    </parser-snapshot>
    <!-- Parse timestamp with time zone cast -->
    <parser-snapshot name="sql_datetime_type_1">
        <input>
            select cast('1' as timestamp with time zone);
        </input>
    </parser-snapshot>
    <!-- Parse timestamp(2) with time zone (precision) -->
    <parser-snapshot name="sql_datetime_type_2">
        <input>
            select cast('1' as timestamp (2) with time zone);
        </input>
    </parser-snapshot>
    <!-- Parse time with time zone -->
    <parser-snapshot name="sql_datetime_type_3">
        <input>
            select cast('1' as time with time zone);
        </input>
    </parser-snapshot>
    <!-- Parse time(2) with time zone -->
    <parser-snapshot name="sql_datetime_type_4">
        <input>
            select cast('1' as time (2) with time zone);
        </input>
    </parser-snapshot>
    <!-- Parse interval year type cast -->
    <parser-snapshot name="sql_interval_type_1">
        <input>
            select cast('1' as interval year);
        </input>
    </parser-snapshot>
    <!-- Parse interval(2) type with precision -->
    <parser-snapshot name="sql_interval_type_2">
        <input>
            select cast('1' as interval(2));
        </input>
    </parser-snapshot>
    <!-- Parse generic type cast -->
    <parser-snapshot name="sql_generic_type_1">
        <input>
            select cast('1' as sometype);
        </input>
    </parser-snapshot>
    <!-- Parse bit type cast -->
    <parser-snapshot name="sql_bit_type_1">
        <input>
            select cast('1' as bit);
        </input>
    </parser-snapshot>
    <!-- Parse bit(n) type cast -->
    <parser-snapshot name="sql_bit_type_2">
        <input>
            select cast('1' as bit(2));
        </input>
    </parser-snapshot>
    <!-- Parse bit varying(n) type cast -->
    <parser-snapshot name="sql_bit_type_3">
        <input>
            select cast('1' as bit varying(2));
        </input>
    </parser-snapshot>
    <!-- Parse OPERATOR(schema.+) qualified operator -->
    <parser-snapshot name="select_operators_1">
        <input>
            select 1 operator(someschema.+) 2;
        </input>
    </parser-snapshot>
    <!-- Parse BETWEEN ... AND -->
    <parser-snapshot name="select_between_1">
        <input>
            select 1 between 0 and 3;
        </input>
    </parser-snapshot>
    <!-- Parse BETWEEN ASYMMETRIC -->
    <parser-snapshot name="select_between_2">
        <input>
            select 1 between asymmetric 0 and 3;
        </input>
    </parser-snapshot>
    <!-- Parse NOT BETWEEN -->
    <parser-snapshot name="select_between_3">
        <input>
            select 1 not between 0 and 3;
        </input>
    </parser-snapshot>
    <!-- Parse NOT BETWEEN ASYMMETRIC -->
    <parser-snapshot name="select_between_4">
        <input>
            select 1 not between asymmetric 0 and 3;
        </input>
    </parser-snapshot>
    <!-- Parse BETWEEN SYMMETRIC -->
    <parser-snapshot name="select_between_5">
        <input>
            select 1 between symmetric 0 and 3;
        </input>
    </parser-snapshot>
    <!-- Parse NOT BETWEEN SYMMETRIC -->
    <parser-snapshot name="select_between_6">
        <input>
            select 1 not between symmetric 0 and 3;
        </input>
    </parser-snapshot>
    <!-- Parse AT TIME ZONE -->
    <parser-snapshot name="select_attimezone_1">
        <input>
            select '2001-02-16 20:38:40' at time zone 'mst';
        </input>
    </parser-snapshot>
    <!-- Parse :: type cast -->
    <parser-snapshot name="select_typecast_1">
        <input>
            select 1::integer;
        </input>
    </parser-snapshot>
    <!-- Parse COLLATE clause -->
    <parser-snapshot name="select_collate_1">
        <input>
            select 1 collate foo;
        </input>
    </parser-snapshot>
    <!-- Parse OVERLAPS for date ranges -->
    <parser-snapshot name="select_overlaps_1">
        <input>
            select (date '2021-01-10', date '2021-02-01') overlaps (date '2021-01-20', date '2021-02-10');
        </input>
    </parser-snapshot>
    <!-- Parse IS DISTINCT FROM -->
    <parser-snapshot name="select_distinct_1">
        <input>
            select a is distinct from b;
        </input>
    </parser-snapshot>
    <!-- Parse IS NOT DISTINCT FROM -->
    <parser-snapshot name="select_distinct_2">
        <input>
            select a is not distinct from b;
        </input>
    </parser-snapshot>
    <!-- Parse IS OF (type) -->
    <parser-snapshot name="select_isof_1">
        <input>
            select a is of (integer);
        </input>
    </parser-snapshot>
    <!-- Parse IS NOT OF (type) -->
    <parser-snapshot name="select_isof_2">
        <input>
            select a is not of (integer);
        </input>
    </parser-snapshot>
    <!-- Parse CASE WHEN with multiple branches (no ELSE) -->
    <parser-snapshot name="select_case_1">
        <input>
            select case a
                when 1 then 2
                when 2 then 3
            end;
        </input>
    </parser-snapshot>
    <!-- Parse CASE WHEN with ELSE -->
    <parser-snapshot name="select_case_2">
        <input>
            select case a
                when 1 then 2
                else  3
            end;
        </input>
    </parser-snapshot>
    <!-- Parse positional parameter $1 -->
    <parser-snapshot name="select_param_2">
        <input>
            select $1 from c
        </input>
    </parser-snapshot>
    <!-- Parse simple function call -->
    <parser-snapshot name="select_func_1">
        <input>
            select somefunc(1)
        </input>
    </parser-snapshot>
    <!-- Parse window function with OVER -->
    <parser-snapshot name="select_func_2">
        <input>
            select somefunc(1) over (partition by c)
        </input>
    </parser-snapshot>
    <!-- Parse aggregate with WITHIN GROUP (ORDER BY) -->
    <parser-snapshot name="select_func_3">
        <input>
            select somefunc(1) within group (order by c)
        </input>
    </parser-snapshot>
    <!-- Parse aggregate with FILTER (WHERE) -->
    <parser-snapshot name="select_func_4">
        <input>
            select somefunc(1) filter (where a = b)
        </input>
    </parser-snapshot>
    <!-- Parse scalar subquery in expression -->
    <parser-snapshot name="select_select_1">
        <input>
            select (select 1)
        </input>
    </parser-snapshot>
    <!-- Parse subquery with field access (.foo) -->
    <parser-snapshot name="select_select_2">
        <input>
            select (select a from b).foo
        </input>
    </parser-snapshot>
    <!-- Parse EXISTS (subquery) -->
    <parser-snapshot name="select_select_3">
        <input>
            select exists (select a)
        </input>
    </parser-snapshot>
    <!-- Parse composite field indirection (a).foo -->
    <parser-snapshot name="select_indirection_1">
        <input>
            select (a).foo
        </input>
    </parser-snapshot>
    <!-- Parse IN (subquery) -->
    <parser-snapshot name="select_in_1">
        <input>
            select a in (select 1)
        </input>
    </parser-snapshot>
    <!-- Parse IN (value list) -->
    <parser-snapshot name="select_in_2">
        <input>
            select a in (2, 3)
        </input>
    </parser-snapshot>
    <!-- Parse LIKE ALL (subquery) -->
    <parser-snapshot name="select_subquery_1">
        <input>
            select a like all (select 1);
        </input>
    </parser-snapshot>
    <!-- Parse LIKE ANY (subquery) -->
    <parser-snapshot name="select_subquery_2">
        <input>
            select a like any (select 1);
        </input>
    </parser-snapshot>
    <!-- Parse LIKE SOME (subquery) -->
    <parser-snapshot name="select_subquery_3">
        <input>
            select a like some (select 1);
        </input>
    </parser-snapshot>
    <!-- Parse LIKE SOME (function call) -->
    <parser-snapshot name="select_subquery_4">
        <input>
            select a like some (foo('bar'));
        </input>
    </parser-snapshot>
    <!-- Parse DEFAULT in function argument -->
    <parser-snapshot name="select_default">
        <input>
            select somefunc(default);
        </input>
    </parser-snapshot>
    <!-- Parse current_date -->
    <parser-snapshot name="select_knownfunc_1">
        <input>
            select current_date;
        </input>
    </parser-snapshot>
    <!-- Parse current_time -->
    <parser-snapshot name="select_knownfunc_2">
        <input>
            select current_time;
        </input>
    </parser-snapshot>
    <!-- Parse current_timestamp -->
    <parser-snapshot name="select_knownfunc_3">
        <input>
            select current_timestamp;
        </input>
    </parser-snapshot>
    <!-- Parse localtime -->
    <parser-snapshot name="select_knownfunc_4">
        <input>
            select localtime;
        </input>
    </parser-snapshot>
    <!-- Parse localtimestamp -->
    <parser-snapshot name="select_knownfunc_5">
        <input>
            select localtimestamp;
        </input>
    </parser-snapshot>
    <!-- Parse current_time with precision -->
    <parser-snapshot name="select_knownfunc_7">
        <input>
            select current_time(42);
        </input>
    </parser-snapshot>
    <!-- Parse current_timestamp with precision -->
    <parser-snapshot name="select_knownfunc_8">
        <input>
            select current_timestamp(42);
        </input>
    </parser-snapshot>
    <!-- Parse localtime with precision -->
    <parser-snapshot name="select_knownfunc_9">
        <input>
            select localtime(42);
        </input>
    </parser-snapshot>
    <!-- Parse localtimestamp with precision -->
    <parser-snapshot name="select_knownfunc_10">
        <input>
            select localtimestamp(42);
        </input>
    </parser-snapshot>
    <!-- Parse current_role -->
    <parser-snapshot name="select_knownfunc_11">
        <input>
            select current_role;
        </input>
    </parser-snapshot>
    <!-- Parse current_user -->
    <parser-snapshot name="select_knownfunc_12">
        <input>
            select current_user;
        </input>
    </parser-snapshot>
    <!-- Parse session_user -->
    <parser-snapshot name="select_knownfunc_13">
        <input>
            select session_user;
        </input>
    </parser-snapshot>
    <!-- Parse user -->
    <parser-snapshot name="select_knownfunc_14">
        <input>
            select user;
        </input>
    </parser-snapshot>
    <!-- Parse current_catalog -->
    <parser-snapshot name="select_knownfunc_15">
        <input>
            select current_catalog;
        </input>
    </parser-snapshot>
    <!-- Parse current_schema -->
    <parser-snapshot name="select_knownfunc_16">
        <input>
            select current_schema;
        </input>
    </parser-snapshot>
    <!-- Parse cast(expr AS type) -->
    <parser-snapshot name="select_knownfunc_17">
        <input>
            select cast(1 as integer);
        </input>
    </parser-snapshot>
    <!-- Parse treat(expr AS type) -->
    <parser-snapshot name="select_knownfunc_18">
        <input>
            select treat(1 as integer);
        </input>
    </parser-snapshot>
    <!-- Parse nullif(a, b) -->
    <parser-snapshot name="select_knownfunc_19">
        <input>
            select nullif(a, 1);
        </input>
    </parser-snapshot>
    <!-- Parse coalesce(a, b) -->
    <parser-snapshot name="select_knownfunc_20">
        <input>
            select coalesce(a, b);
        </input>
    </parser-snapshot>
    <!-- Parse trim(both 'chars') -->
    <parser-snapshot name="select_knownfunc_21">
        <input>
            select trim(both 'foo');
        </input>
    </parser-snapshot>
    <!-- Parse trim(both from string) -->
    <parser-snapshot name="select_knownfunc_22">
        <input>
            select trim(both from 'foo');
        </input>
    </parser-snapshot>
    <!-- Parse trim(both chars from string) -->
    <parser-snapshot name="select_knownfunc_23">
        <input>
            select trim(both ' \n' from 'foo');
        </input>
    </parser-snapshot>
    <!-- Parse trim with multiple character arguments -->
    <parser-snapshot name="select_knownfunc_24">
        <input>
            select trim(both ' \n' from 'foo', 'bar');
        </input>
    </parser-snapshot>
    <!-- Parse trim(leading from string) -->
    <parser-snapshot name="select_knownfunc_25">
        <input>
            select trim(leading from 'foo');
        </input>
    </parser-snapshot>
    <!-- Parse trim(trailing from string) -->
    <parser-snapshot name="select_knownfunc_26">
        <input>
            select trim(trailing from 'foo');
        </input>
    </parser-snapshot>
    <!-- Parse trim(string) single-arg form -->
    <parser-snapshot name="select_knownfunc_27">
        <input>
            select trim('foo');
        </input>
    </parser-snapshot>
    <!-- Parse extract(field FROM expr) -->
    <parser-snapshot name="select_knownfunc_28">
        <input>
            select extract(day from a) from foo;
        </input>
    </parser-snapshot>
    <!-- Parse extract(year from timestamp literal) -->
    <parser-snapshot name="select_knownfunc_28_1">
        <input>
            select extract(year from timestamp '2016-12-31 13:30:15');
        </input>
    </parser-snapshot>
    <!-- Parse substring from/for syntax -->
    <parser-snapshot name="select_knownfunc_29">
        <input>
            select substring('foobar' from 1 for 2);
        </input>
    </parser-snapshot>
    <!-- Parse substring from (no for) -->
    <parser-snapshot name="select_knownfunc_30">
        <input>
            select substring('foobar' from 1);
        </input>
    </parser-snapshot>
    <!-- Parse substring for (no from) -->
    <parser-snapshot name="select_knownfunc_31">
        <input>
            select substring('foobar' for 1);
        </input>
    </parser-snapshot>
    <!-- Parse substring(str, start, length) -->
    <parser-snapshot name="select_knownfunc_32">
        <input>
            select substring('foobar', 1, 4);
        </input>
    </parser-snapshot>
    <!-- Parse substring(str, start) two-arg form -->
    <parser-snapshot name="select_knownfunc_33">
        <input>
            select substring('foobar', 1);
        </input>
    </parser-snapshot>
    <!-- Parse position(substr IN str) -->
    <parser-snapshot name="select_knownfunc_34">
        <input>
            select position('bar' in 'foobar');
        </input>
    </parser-snapshot>
    <!-- Parse overlay(string PLACING new FROM start) -->
    <parser-snapshot name="select_knownfunc_35">
        <input>
            SELECT overlay('foooooooooooooooooo' placing 'bar' from 3);
        </input>
    </parser-snapshot>
    <!-- Parse FROM generate_series(...) -->
    <parser-snapshot name="select_table_func_1">
        <input>
            SELECT * FROM generate_series(1);
        </input>
    </parser-snapshot>
    <!-- Parse FROM func() WITH ORDINALITY -->
    <parser-snapshot name="select_table_func_2">
        <input>
            SELECT * FROM generate_series(1) WITH ORDINALITY;
        </input>
    </parser-snapshot>
    <!-- Parse ROWS FROM (multiple functions) -->
    <parser-snapshot name="select_table_func_3">
        <input>
            SELECT * FROM ROWS FROM (generate_series(1), generate_series(2));
        </input>
    </parser-snapshot>
    <!-- Parse ROWS FROM with column definitions -->
    <parser-snapshot name="select_table_func_4">
        <input>
            SELECT * FROM ROWS FROM (generate_series(1) as (a integer), generate_series(2) as (a integer));
        </input>
    </parser-snapshot>
    <!-- Parse ROWS FROM with COLLATE in column defs -->
    <parser-snapshot name="select_table_func_5">
        <input>
            SELECT * FROM
                ROWS FROM (
                    generate_series(1) as (a varchar collate "de_DE"),
                    generate_series(2) as (a varchar collate "de_DE")
                );
        </input>
    </parser-snapshot>
    <!-- Parse USING SAMPLE n rows -->
    <parser-snapshot name="select_sample_1">
        <input>
            SELECT * FROM tbl USING SAMPLE 5;
        </input>
    </parser-snapshot>
    <!-- Parse USING SAMPLE n% -->
    <parser-snapshot name="select_sample_2">
        <input>
            SELECT * FROM tbl USING SAMPLE 10%;
        </input>
    </parser-snapshot>
    <!-- Parse USING SAMPLE n PERCENT (method) -->
    <parser-snapshot name="select_sample_3">
        <input>
            SELECT * FROM tbl USING SAMPLE 10 PERCENT (bernoulli);
        </input>
    </parser-snapshot>
    <!-- Parse USING SAMPLE reservoir(...) REPEATABLE -->
    <parser-snapshot name="select_sample_4">
        <input>
            SELECT * FROM tbl USING SAMPLE reservoir(50 ROWS) REPEATABLE (100);
        </input>
    </parser-snapshot>
    <!-- Parse USING SAMPLE with method and seed -->
    <parser-snapshot name="select_sample_5">
        <input>
            SELECT * FROM tbl USING SAMPLE 10% (system, 377);
        </input>
    </parser-snapshot>
    <!-- Parse TABLESAMPLE on one table in multi-table FROM -->
    <parser-snapshot name="select_sample_6">
        <input>
            SELECT * FROM tbl TABLESAMPLE RESERVOIR(20%), tbl2 WHERE tbl.i=tbl2.i;
        </input>
    </parser-snapshot>
    <!-- Parse USING SAMPLE applying to join -->
    <parser-snapshot name="select_sample_7">
        <input>
            SELECT * FROM tbl, tbl2 WHERE tbl.i=tbl2.i USING SAMPLE RESERVOIR(20%);
        </input>
    </parser-snapshot>
    <!-- Parse INNER JOIN ... ON -->
    <parser-snapshot name="select_join_1">
        <input>
            SELECT * FROM a INNER JOIN b ON c = d
        </input>
    </parser-snapshot>
    <!-- Parse JOIN ... ON (inner) -->
    <parser-snapshot name="select_join_2">
        <input>
            SELECT * FROM a JOIN b ON c = d
        </input>
    </parser-snapshot>
    <!-- Parse CROSS JOIN -->
    <parser-snapshot name="select_join_3">
        <input>
            SELECT * FROM a CROSS JOIN b
        </input>
    </parser-snapshot>
    <!-- Parse NATURAL JOIN -->
    <parser-snapshot name="select_join_4">
        <input>
            SELECT * FROM a NATURAL JOIN b
        </input>
    </parser-snapshot>
    <!-- Parse LEFT OUTER JOIN ... ON -->
    <parser-snapshot name="select_join_5">
        <input>
            SELECT * FROM a LEFT OUTER JOIN b ON c = d
        </input>
    </parser-snapshot>
    <!-- Parse LEFT JOIN ... ON -->
    <parser-snapshot name="select_join_6">
        <input>
            SELECT * FROM a LEFT JOIN b ON foo = d
        </input>
    </parser-snapshot>
    <!-- Parse RIGHT JOIN ... ON -->
    <parser-snapshot name="select_join_7">
        <input>
            SELECT * FROM a RIGHT JOIN b ON c = d
        </input>
    </parser-snapshot>
    <!-- Parse FULL OUTER JOIN ... ON -->
    <parser-snapshot name="select_join_8">
        <input>
            SELECT * FROM a FULL OUTER JOIN b ON c = d
        </input>
    </parser-snapshot>
    <!-- Parse INNER JOIN ... USING (cols) -->
    <parser-snapshot name="select_join_9">
        <input>
            SELECT * FROM a INNER JOIN b USING (c, d)
        </input>
    </parser-snapshot>
    <!-- Parse FOR UPDATE -->
    <parser-snapshot name="select_row_locking_1">
        <input>
            SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;
        </input>
    </parser-snapshot>
    <!-- Parse FOR NO KEY UPDATE -->
    <parser-snapshot name="select_row_locking_2">
        <input>
            SELECT * FROM (SELECT * FROM mytable FOR NO KEY UPDATE) ss WHERE col1 = 5;
        </input>
    </parser-snapshot>
    <!-- Parse FOR SHARE -->
    <parser-snapshot name="select_row_locking_3">
        <input>
            SELECT * FROM (SELECT * FROM mytable FOR SHARE) ss WHERE col1 = 5;
        </input>
    </parser-snapshot>
    <!-- Parse FOR KEY SHARE -->
    <parser-snapshot name="select_row_locking_4">
        <input>
            SELECT * FROM (SELECT * FROM mytable FOR KEY SHARE) ss WHERE col1 = 5;
        </input>
    </parser-snapshot>
    <!-- Parse FOR READ ONLY -->
    <parser-snapshot name="select_row_locking_5">
        <input>
            SELECT * FROM (SELECT * FROM mytable FOR READ ONLY) ss WHERE col1 = 5;
        </input>
    </parser-snapshot>
    <!-- Parse FOR UPDATE OF table -->
    <parser-snapshot name="select_row_locking_6">
        <input>
            SELECT * FROM (SELECT * FROM mytable FOR UPDATE OF foo) ss WHERE col1 = 5;
        </input>
    </parser-snapshot>
    <!-- Parse FOR UPDATE OF table NOWAIT -->
    <parser-snapshot name="select_row_locking_7">
        <input>
            SELECT * FROM (SELECT * FROM mytable FOR UPDATE OF foo NOWAIT) ss WHERE col1 = 5;
        </input>
    </parser-snapshot>
    <!-- Parse LIMIT n -->
    <parser-snapshot name="select_limit_1">
        <input>
            SELECT * FROM foo LIMIT 42
        </input>
    </parser-snapshot>
    <!-- Parse LIMIT n OFFSET m -->
    <parser-snapshot name="select_limit_2">
        <input>
            SELECT * FROM foo LIMIT 42 OFFSET 21
        </input>
    </parser-snapshot>
    <!-- Parse LIMIT ALL -->
    <parser-snapshot name="select_limit_3">
        <input>
            SELECT * FROM foo LIMIT ALL
        </input>
    </parser-snapshot>
    <!-- Parse LIMIT ALL OFFSET m -->
    <parser-snapshot name="select_limit_4">
        <input>
            SELECT * FROM foo LIMIT ALL OFFSET 21
        </input>
    </parser-snapshot>
    <!-- Parse FETCH FIRST n ROWS ONLY -->
    <parser-snapshot name="select_limit_5">
        <input>
            SELECT * FROM foo FETCH FIRST 42 ROWS ONLY
        </input>
    </parser-snapshot>
    <!-- Parse FETCH FIRST 1 ROW ONLY -->
    <parser-snapshot name="select_limit_6">
        <input>
            SELECT * FROM foo FETCH FIRST 1 ROW ONLY
        </input>
    </parser-snapshot>
    <!-- Parse FETCH NEXT n ROW ONLY -->
    <parser-snapshot name="select_limit_7">
        <input>
            SELECT * FROM foo FETCH NEXT 1 ROW ONLY
        </input>
    </parser-snapshot>
    <!-- Parse LIMIT ALL, n (offset as second arg) -->
    <parser-snapshot name="select_limit_8">
        <input>
            SELECT * FROM foo LIMIT ALL, 21
        </input>
    </parser-snapshot>
    <!-- Parse FROM func() AS alias(col type) -->
    <parser-snapshot name="select_alias_1">
        <input>
            select v into a FROM somefunc() as t(a integer);
        </input>
    </parser-snapshot>
</parser-snapshots>
