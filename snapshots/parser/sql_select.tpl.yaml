parser-snapshots:
  # Parse SELECT NULL literal
  - name: select_null
    input: |
      select null
  # Parse integer constant
  - name: select_iconst_1
    input: |
      select 1
  # Parse float constant in scientific notation
  - name: select_fconst_1e04
    input: |
      select 1e-04
  # Parse bit string constant
  - name: select_bconst_b1010
    input: |
      select b'1010'
  # Parse unquoted string (identifier)
  - name: select_sconst_string
    input: |
      select string
  # Parse string with Latin-1 characters
  - name: select_sconst_string_latin1
    input: |
      select Ã¤Ã¶Ã¼
  # Parse string with Unicode plane 1 character (emoji)
  - name: select_sconst_string_unicode_plane1
    input: |
      select ðŸ“ˆ
  # Parse comparison expression
  - name: select_1_gt_2
    input: |
      select 1 > 2
  # Parse single-quoted string literal
  - name: select_sconst_quotes
    input: |
      select 'foo'
  # Parse string with escaped single quote
  - name: select_sconst_quotes_nested_quote
    input: |
      select '''foo'''
  # Parse string containing double-quoted substring
  - name: select_sconst_quotes_nested_dquote
    input: |
      select '"foo"'
  # Parse literal followed by quoted identifier
  - name: select_iconst_1_ident
    input: |
      select 1 "foo"
  # Parse C-style block comment
  - name: comments_cstyle
    input: |
      /* foo */
  # Parse nested C-style comments
  - name: comments_cstyle_nested
    input: |
      /* foo /* bar */ */
  # Parse select list with multiple expressions
  - name: select_iconst_list
    input: |
      select 1, 2
  # Parse FROM with single table reference
  - name: select_from_1rel
    input: |
      select a from b
  # Parse FROM with schema-qualified table (b.c)
  - name: select_from_1rel_indirect1
    input: |
      select a from b.c
  # Parse FROM with ONLY before schema-qualified table
  - name: select_from_1rel_indirect1_noinherit
    input: |
      select a from only b.c
  # Parse FROM with schema-qualified table and AS alias
  - name: select_from_1rel_indirect1_alias
    input: |
      select a from b.c as d
  # Parse FROM with two table references (comma join)
  - name: select_from_2rel
    input: |
      select a from b, c
  # Parse SELECT INTO with multiple tables
  - name: select_from_into_2rel
    input: |
      select a into b from c, d
  # Parse GROUP BY with position reference
  - name: select_from_1rel_group1
    input: |
      select a from b group by 1
  # Parse named window with empty definition
  - name: select_from_1rel_window_empty
    input: |
      select a from b window c as ()
  # Parse window with PARTITION BY
  - name: select_from_1rel_window_partition1
    input: |
      select a from b window c as (partition by d)
  # Parse window with ROWS BETWEEN unbounded frame
  - name: select_from_1rel_window_partition1_rows_unbounded
    input: |
      select a from b
                  window c as (partition by d rows between unbounded preceding and unbounded following)
  # Parse window with ROWS 1 PRECEDING AND CURRENT ROW
  - name: select_from_1rel_window_partition1_rows_1preceding_current
    input: |
      select a from b
                  window c as (partition by d rows between 1 preceding and current row)
  # Parse multiple named window definitions
  - name: select_from_1rel_2windows
    input: |
      select a from b
                  window c as (partition by d range between current row and 1 following),
                          e as (partition by f)
  # Parse SELECT DISTINCT
  - name: select_distinct_from_1rel
    input: |
      select distinct a from b
  # Parse SELECT DISTINCT ON (expr)
  - name: select_distinct_on_from_1rel
    input: |
      select distinct on (a) a from b
  # Parse SELECT ALL (column named "all")
  - name: select_all_from_1rel
    input: |
      select all from b
  # Parse VALUES with single row
  - name: values_1
    input: |
      values (1)
  # Parse VALUES with multiple rows
  - name: values_1_2
    input: |
      values (1), (2);
  # Parse VALUES with multiple columns per row
  - name: values_12_34
    input: |
      values (1, 2), (3, 4)
  # Parse TABLE table_ref (shorthand for SELECT * FROM)
  - name: table_a
    input: |
      TABLE a
  # Parse UNION of two selects
  - name: union_select1_select2
    input: |
      SELECT 1 UNION SELECT 2
  # Parse UNION ALL
  - name: union_all_select1_select2
    input: |
      SELECT 1 UNION ALL SELECT 2
  # Parse UNION DISTINCT
  - name: union_distinct_select1_select2
    input: |
      SELECT 1 UNION DISTINCT SELECT 2
  # Parse INTERSECT
  - name: intersect_select1_select2
    input: |
      SELECT 1 INTERSECT SELECT 2
  # Parse WITH single CTE
  - name: with_1cte_select2
    input: |
      WITH a AS (SELECT 1) SELECT 2
  # Parse WITH multiple CTEs
  - name: with_2ctes_select3
    input: |
      WITH a AS (SELECT 1), b AS (SELECT 2) SELECT 3
  # Parse WITH RECURSIVE and multiple CTEs
  - name: with_recursive_2ctes_select3
    input: |
      WITH RECURSIVE a AS (SELECT 1), b AS (SELECT 2) SELECT 3
  # Parse ORDER BY single column
  - name: select_a_orderby_b
    input: |
      select a order by b
  # Parse ORDER BY multiple columns
  - name: select_a_orderby_b_c
    input: |
      select a order by b, c
  # Parse ORDER BY with ASC/DESC
  - name: select_a_orderby_b_c_directions
    input: |
      select a order by b asc, c desc
  # Parse ORDER BY with NULLS FIRST/LAST
  - name: select_a_orderby_b_c_directions_nulls
    input: |
      select a order by b asc nulls first, c desc nulls last
  # Parse SELECT INTO and subsequent FROM referencing created table
  - name: select_table_ref
    input: |
      select 1 into b;
                  select 1 from b;
  # Parse join with table aliases and WHERE
  - name: select_table_ref_1
    input: |
      select * from A a, B b where a.x = b.y
  # Parse parameter reference in expression ($a + 1)
  - name: select_column_ref_expr_1
    input: |
      select 1 into b;
                  select c from b where c = $a + 1
  # Parse multiple parameters in WHERE
  - name: select_column_ref_expr_2
    input: |
      select * into countries_joined from country1_weather c1, country2_weather c2 where c1.month = c2.month and c2.month = $month
  # Parse set-returning function with column alias
  - name: select_generate_series
    input: |
      select v into a FROM generate_series(0, 10000) as t(v);
  # Parse table-valued function in FROM
  - name: select_functable
    input: |
      select * from somefunc('somearg') foo;
  # Parse function call with constant argument (no parens around constant)
  - name: select_funcconst_1
    input: |
      select somefunc 'foo';
  # Parse function call with parens and trailing constant
  - name: select_funcconst_2
    input: |
      select somefunc(1) 'foo';
  # Parse type cast: typename 'value'
  - name: select_const_typename_cast
    input: |
      select integer '1';
  # Parse INTERVAL with minute to second range
  - name: select_const_interval_1
    input: |
      select interval '90' minute to second;
  # Parse INTERVAL with single unit (hour)
  - name: select_const_interval_2
    input: |
      select interval '90' hour;
  # Parse INTERVAL with numeric value and unit
  - name: select_const_interval_3
    input: |
      select interval 1 hour;
  # Parse timestamp with time zone cast
  - name: sql_datetime_type_1
    input: |
      select cast('1' as timestamp with time zone);
  # Parse timestamp(2) with time zone (precision)
  - name: sql_datetime_type_2
    input: |
      select cast('1' as timestamp (2) with time zone);
  # Parse time with time zone
  - name: sql_datetime_type_3
    input: |
      select cast('1' as time with time zone);
  # Parse time(2) with time zone
  - name: sql_datetime_type_4
    input: |
      select cast('1' as time (2) with time zone);
  # Parse interval year type cast
  - name: sql_interval_type_1
    input: |
      select cast('1' as interval year);
  # Parse interval(2) type with precision
  - name: sql_interval_type_2
    input: |
      select cast('1' as interval(2));
  # Parse generic type cast
  - name: sql_generic_type_1
    input: |
      select cast('1' as sometype);
  # Parse bit type cast
  - name: sql_bit_type_1
    input: |
      select cast('1' as bit);
  # Parse bit(n) type cast
  - name: sql_bit_type_2
    input: |
      select cast('1' as bit(2));
  # Parse bit varying(n) type cast
  - name: sql_bit_type_3
    input: |
      select cast('1' as bit varying(2));
  # Parse OPERATOR(schema.+) qualified operator
  - name: select_operators_1
    input: |
      select 1 operator(someschema.+) 2;
  # Parse BETWEEN ... AND
  - name: select_between_1
    input: |
      select 1 between 0 and 3;
  # Parse BETWEEN ASYMMETRIC
  - name: select_between_2
    input: |
      select 1 between asymmetric 0 and 3;
  # Parse NOT BETWEEN
  - name: select_between_3
    input: |
      select 1 not between 0 and 3;
  # Parse NOT BETWEEN ASYMMETRIC
  - name: select_between_4
    input: |
      select 1 not between asymmetric 0 and 3;
  # Parse BETWEEN SYMMETRIC
  - name: select_between_5
    input: |
      select 1 between symmetric 0 and 3;
  # Parse NOT BETWEEN SYMMETRIC
  - name: select_between_6
    input: |
      select 1 not between symmetric 0 and 3;
  # Parse AT TIME ZONE
  - name: select_attimezone_1
    input: |
      select '2001-02-16 20:38:40' at time zone 'mst';
  # Parse :: type cast
  - name: select_typecast_1
    input: |
      select 1::integer;
  # Parse COLLATE clause
  - name: select_collate_1
    input: |
      select 1 collate foo;
  # Parse OVERLAPS for date ranges
  - name: select_overlaps_1
    input: |
      select (date '2021-01-10', date '2021-02-01') overlaps (date '2021-01-20', date '2021-02-10');
  # Parse IS DISTINCT FROM
  - name: select_distinct_1
    input: |
      select a is distinct from b;
  # Parse IS NOT DISTINCT FROM
  - name: select_distinct_2
    input: |
      select a is not distinct from b;
  # Parse IS OF (type)
  - name: select_isof_1
    input: |
      select a is of (integer);
  # Parse IS NOT OF (type)
  - name: select_isof_2
    input: |
      select a is not of (integer);
  # Parse CASE WHEN with multiple branches (no ELSE)
  - name: select_case_1
    input: |
      select case a
                      when 1 then 2
                      when 2 then 3
                  end;
  # Parse CASE WHEN with ELSE
  - name: select_case_2
    input: |
      select case a
                      when 1 then 2
                      else  3
                  end;
  # Parse positional parameter $1
  - name: select_param_2
    input: |
      select $1 from c
  # Parse simple function call
  - name: select_func_1
    input: |
      select somefunc(1)
  # Parse window function with OVER
  - name: select_func_2
    input: |
      select somefunc(1) over (partition by c)
  # Parse aggregate with WITHIN GROUP (ORDER BY)
  - name: select_func_3
    input: |
      select somefunc(1) within group (order by c)
  # Parse aggregate with FILTER (WHERE)
  - name: select_func_4
    input: |
      select somefunc(1) filter (where a = b)
  # Parse scalar subquery in expression
  - name: select_select_1
    input: |
      select (select 1)
  # Parse subquery with field access (.foo)
  - name: select_select_2
    input: |
      select (select a from b).foo
  # Parse EXISTS (subquery)
  - name: select_select_3
    input: |
      select exists (select a)
  # Parse composite field indirection (a).foo
  - name: select_indirection_1
    input: |
      select (a).foo
  # Parse IN (subquery)
  - name: select_in_1
    input: |
      select a in (select 1)
  # Parse IN (value list)
  - name: select_in_2
    input: |
      select a in (2, 3)
  # Parse LIKE ALL (subquery)
  - name: select_subquery_1
    input: |
      select a like all (select 1);
  # Parse LIKE ANY (subquery)
  - name: select_subquery_2
    input: |
      select a like any (select 1);
  # Parse LIKE SOME (subquery)
  - name: select_subquery_3
    input: |
      select a like some (select 1);
  # Parse LIKE SOME (function call)
  - name: select_subquery_4
    input: |
      select a like some (foo('bar'));
  # Parse DEFAULT in function argument
  - name: select_default
    input: |
      select somefunc(default);
  # Parse current_date
  - name: select_knownfunc_1
    input: |
      select current_date;
  # Parse current_time
  - name: select_knownfunc_2
    input: |
      select current_time;
  # Parse current_timestamp
  - name: select_knownfunc_3
    input: |
      select current_timestamp;
  # Parse localtime
  - name: select_knownfunc_4
    input: |
      select localtime;
  # Parse localtimestamp
  - name: select_knownfunc_5
    input: |
      select localtimestamp;
  # Parse current_time with precision
  - name: select_knownfunc_7
    input: |
      select current_time(42);
  # Parse current_timestamp with precision
  - name: select_knownfunc_8
    input: |
      select current_timestamp(42);
  # Parse localtime with precision
  - name: select_knownfunc_9
    input: |
      select localtime(42);
  # Parse localtimestamp with precision
  - name: select_knownfunc_10
    input: |
      select localtimestamp(42);
  # Parse current_role
  - name: select_knownfunc_11
    input: |
      select current_role;
  # Parse current_user
  - name: select_knownfunc_12
    input: |
      select current_user;
  # Parse session_user
  - name: select_knownfunc_13
    input: |
      select session_user;
  # Parse user
  - name: select_knownfunc_14
    input: |
      select user;
  # Parse current_catalog
  - name: select_knownfunc_15
    input: |
      select current_catalog;
  # Parse current_schema
  - name: select_knownfunc_16
    input: |
      select current_schema;
  # Parse cast(expr AS type)
  - name: select_knownfunc_17
    input: |
      select cast(1 as integer);
  # Parse treat(expr AS type)
  - name: select_knownfunc_18
    input: |
      select treat(1 as integer);
  # Parse nullif(a, b)
  - name: select_knownfunc_19
    input: |
      select nullif(a, 1);
  # Parse coalesce(a, b)
  - name: select_knownfunc_20
    input: |
      select coalesce(a, b);
  # Parse trim(both 'chars')
  - name: select_knownfunc_21
    input: |
      select trim(both 'foo');
  # Parse trim(both from string)
  - name: select_knownfunc_22
    input: |
      select trim(both from 'foo');
  # Parse trim(both chars from string)
  - name: select_knownfunc_23
    input: |
      select trim(both ' \n' from 'foo');
  # Parse trim with multiple character arguments
  - name: select_knownfunc_24
    input: |
      select trim(both ' \n' from 'foo', 'bar');
  # Parse trim(leading from string)
  - name: select_knownfunc_25
    input: |
      select trim(leading from 'foo');
  # Parse trim(trailing from string)
  - name: select_knownfunc_26
    input: |
      select trim(trailing from 'foo');
  # Parse trim(string) single-arg form
  - name: select_knownfunc_27
    input: |
      select trim('foo');
  # Parse extract(field FROM expr)
  - name: select_knownfunc_28
    input: |
      select extract(day from a) from foo;
  # Parse extract(year from timestamp literal)
  - name: select_knownfunc_28_1
    input: |
      select extract(year from timestamp '2016-12-31 13:30:15');
  # Parse substring from/for syntax
  - name: select_knownfunc_29
    input: |
      select substring('foobar' from 1 for 2);
  # Parse substring from (no for)
  - name: select_knownfunc_30
    input: |
      select substring('foobar' from 1);
  # Parse substring for (no from)
  - name: select_knownfunc_31
    input: |
      select substring('foobar' for 1);
  # Parse substring(str, start, length)
  - name: select_knownfunc_32
    input: |
      select substring('foobar', 1, 4);
  # Parse substring(str, start) two-arg form
  - name: select_knownfunc_33
    input: |
      select substring('foobar', 1);
  # Parse position(substr IN str)
  - name: select_knownfunc_34
    input: |
      select position('bar' in 'foobar');
  # Parse overlay(string PLACING new FROM start)
  - name: select_knownfunc_35
    input: |
      SELECT overlay('foooooooooooooooooo' placing 'bar' from 3);
  # Parse FROM generate_series(...)
  - name: select_table_func_1
    input: |
      SELECT * FROM generate_series(1);
  # Parse FROM func() WITH ORDINALITY
  - name: select_table_func_2
    input: |
      SELECT * FROM generate_series(1) WITH ORDINALITY;
  # Parse ROWS FROM (multiple functions)
  - name: select_table_func_3
    input: |
      SELECT * FROM ROWS FROM (generate_series(1), generate_series(2));
  # Parse ROWS FROM with column definitions
  - name: select_table_func_4
    input: |
      SELECT * FROM ROWS FROM (generate_series(1) as (a integer), generate_series(2) as (a integer));
  # Parse ROWS FROM with COLLATE in column defs
  - name: select_table_func_5
    input: |
      SELECT * FROM
                      ROWS FROM (
                          generate_series(1) as (a varchar collate "de_DE"),
                          generate_series(2) as (a varchar collate "de_DE")
                      );
  # Parse USING SAMPLE n rows
  - name: select_sample_1
    input: |
      SELECT * FROM tbl USING SAMPLE 5;
  # Parse USING SAMPLE n%
  - name: select_sample_2
    input: |
      SELECT * FROM tbl USING SAMPLE 10%;
  # Parse USING SAMPLE n PERCENT (method)
  - name: select_sample_3
    input: |
      SELECT * FROM tbl USING SAMPLE 10 PERCENT (bernoulli);
  # Parse USING SAMPLE reservoir(...) REPEATABLE
  - name: select_sample_4
    input: |
      SELECT * FROM tbl USING SAMPLE reservoir(50 ROWS) REPEATABLE (100);
  # Parse USING SAMPLE with method and seed
  - name: select_sample_5
    input: |
      SELECT * FROM tbl USING SAMPLE 10% (system, 377);
  # Parse TABLESAMPLE on one table in multi-table FROM
  - name: select_sample_6
    input: |
      SELECT * FROM tbl TABLESAMPLE RESERVOIR(20%), tbl2 WHERE tbl.i=tbl2.i;
  # Parse USING SAMPLE applying to join
  - name: select_sample_7
    input: |
      SELECT * FROM tbl, tbl2 WHERE tbl.i=tbl2.i USING SAMPLE RESERVOIR(20%);
  # Parse INNER JOIN ... ON
  - name: select_join_1
    input: |
      SELECT * FROM a INNER JOIN b ON c = d
  # Parse JOIN ... ON (inner)
  - name: select_join_2
    input: |
      SELECT * FROM a JOIN b ON c = d
  # Parse CROSS JOIN
  - name: select_join_3
    input: |
      SELECT * FROM a CROSS JOIN b
  # Parse NATURAL JOIN
  - name: select_join_4
    input: |
      SELECT * FROM a NATURAL JOIN b
  # Parse LEFT OUTER JOIN ... ON
  - name: select_join_5
    input: |
      SELECT * FROM a LEFT OUTER JOIN b ON c = d
  # Parse LEFT JOIN ... ON
  - name: select_join_6
    input: |
      SELECT * FROM a LEFT JOIN b ON foo = d
  # Parse RIGHT JOIN ... ON
  - name: select_join_7
    input: |
      SELECT * FROM a RIGHT JOIN b ON c = d
  # Parse FULL OUTER JOIN ... ON
  - name: select_join_8
    input: |
      SELECT * FROM a FULL OUTER JOIN b ON c = d
  # Parse INNER JOIN ... USING (cols)
  - name: select_join_9
    input: |
      SELECT * FROM a INNER JOIN b USING (c, d)
  # Parse FOR UPDATE
  - name: select_row_locking_1
    input: |
      SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;
  # Parse FOR NO KEY UPDATE
  - name: select_row_locking_2
    input: |
      SELECT * FROM (SELECT * FROM mytable FOR NO KEY UPDATE) ss WHERE col1 = 5;
  # Parse FOR SHARE
  - name: select_row_locking_3
    input: |
      SELECT * FROM (SELECT * FROM mytable FOR SHARE) ss WHERE col1 = 5;
  # Parse FOR KEY SHARE
  - name: select_row_locking_4
    input: |
      SELECT * FROM (SELECT * FROM mytable FOR KEY SHARE) ss WHERE col1 = 5;
  # Parse FOR READ ONLY
  - name: select_row_locking_5
    input: |
      SELECT * FROM (SELECT * FROM mytable FOR READ ONLY) ss WHERE col1 = 5;
  # Parse FOR UPDATE OF table
  - name: select_row_locking_6
    input: |
      SELECT * FROM (SELECT * FROM mytable FOR UPDATE OF foo) ss WHERE col1 = 5;
  # Parse FOR UPDATE OF table NOWAIT
  - name: select_row_locking_7
    input: |
      SELECT * FROM (SELECT * FROM mytable FOR UPDATE OF foo NOWAIT) ss WHERE col1 = 5;
  # Parse LIMIT n
  - name: select_limit_1
    input: |
      SELECT * FROM foo LIMIT 42
  # Parse LIMIT n OFFSET m
  - name: select_limit_2
    input: |
      SELECT * FROM foo LIMIT 42 OFFSET 21
  # Parse LIMIT ALL
  - name: select_limit_3
    input: |
      SELECT * FROM foo LIMIT ALL
  # Parse LIMIT ALL OFFSET m
  - name: select_limit_4
    input: |
      SELECT * FROM foo LIMIT ALL OFFSET 21
  # Parse FETCH FIRST n ROWS ONLY
  - name: select_limit_5
    input: |
      SELECT * FROM foo FETCH FIRST 42 ROWS ONLY
  # Parse FETCH FIRST 1 ROW ONLY
  - name: select_limit_6
    input: |
      SELECT * FROM foo FETCH FIRST 1 ROW ONLY
  # Parse FETCH NEXT n ROW ONLY
  - name: select_limit_7
    input: |
      SELECT * FROM foo FETCH NEXT 1 ROW ONLY
  # Parse LIMIT ALL, n (offset as second arg)
  - name: select_limit_8
    input: |
      SELECT * FROM foo LIMIT ALL, 21
  # Parse FROM func() AS alias(col type)
  - name: select_alias_1
    input: |
      select v into a FROM somefunc() as t(a integer);
