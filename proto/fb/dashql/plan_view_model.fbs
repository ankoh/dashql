namespace dashql.buffers.view.plan;

table PlanViewModel {
    /// The name dictionary allows us to implement flat catalog entries as flat structs
    name_dictionary: [string];
    /// The pipelines
    pipelines: [PlanPipeline];
    /// The plan nodes
    nodes: [PlanNode];
    /// The attributes
    attributes: [PlanAttribute];
    /// The plan cross edges
    cross_edges: [PlanCrossEdge];
    /// The total width
    total_width: uint32;
    /// The total height
    total_height: uint32;
}

struct ExecutionStatistics {
    /// The time when the target started in milliseconds since epoch
    started_at: uint64;
    /// The time when the target failed in milliseconds since epoch
    failed_at: uint64;
    /// The time when the target finished in milliseconds since epoch
    finished_at: uint64;

    /// The estimated input cardinality
    input_cardinality_estimated: uint64;
    /// The cardinality that has been consumed already
    input_cardinality_consumed: uint64;
    /// The estimated input cardinality
    output_cardinality_estimated: uint64;
    /// The cardinality that has been produced already
    output_cardinality_produced: uint64;
}

struct PlanPipeline {
    /// The pipeline id
    pipeline_id: uint32;
    /// The execution statistics
    statistics: ExecutionStatistics;
}

struct BoundingBox {
    /// The x position of the node
    position_x: uint32;
    /// The y position of the node
    position_y: uint32;
    /// The width of the node
    node_width: uint32;
    /// The height of the node
    node_height: uint32;
}

enum PlanOperatorType: uint8 {
    UNKNOWN = 0,
}

struct PlanNode {
    /// The node id.
    /// May differ from the node index.
    node_id: uint32;
    /// The operator name
    operator_name_id: uint32;
    /// The operator type (if known)
    operator_type: PlanOperatorType;
    /// The output pipeline id
    output_pipeline_id: uint32;

    /// The begin of the children
    children_begin: uint32;
    /// The children count
    children_count: uint32;
    /// The begin of the attributes
    attributes_begin: uint32;
    /// The attribute count
    attribute_count: uint32;
    /// The begin of the cross edges
    cross_edges_begin: uint32;
    /// The number of cross edges
    cross_edge_count: uint32;

    /// The execution statistics
    statistics: ExecutionStatistics;
    /// The rendered bounding box
    rendered: BoundingBox;
}

struct PlanCrossEdge {
    /// The source node
    source_node: uint32;
    /// The target node
    target_node: uint32;
    /// The pipeline id
    pipeline_id: uint32;
}

enum PlanAttributeType: uint8 {
    UNKNOWN = 0,
}

/// This is our container to encode arbitrary attributes in the query plan.
/// We cannot afford to model every single possible plan attribute through flatbuffers.
/// We instead go with a "generic" attribute, with a set of known attribute types.
struct PlanAttribute {
    /// The node id.
    /// May differ from the node index.
    attribute_id: uint32;
    /// The attribute type
    attribute_type: PlanAttributeType;
    /// The attribute name
    attribute_name_id: uint32;
    /// The value text (uint32 max if null)
    value_text: uint32;
    /// The children attributes
    children_begin: uint32;
    /// The children count
    children_count: uint32;
}

/// A change event to update node statistics
table UpdateNodeStatisticsEvent {
    /// The event time
    event_time: uint64;
    /// The node id
    node_id: uint32;
    /// The new statistics
    statistics: ExecutionStatistics;
}

/// A change event to update pipeline statistics
table UpdatePipelineStatisticsEvent {
    /// The event time
    event_time: uint64;
    /// The pipeline id
    pipeline_id: uint32;
    /// The new statistics
    statistics: ExecutionStatistics;
}

union PlanChangeEvent {
    UpdateNodeStatisticsEvent,
    UpdatePipelineStatisticsEvent
}

/// A set of change events
table PlanChangeEvents {
    events: [PlanChangeEvent];
}
