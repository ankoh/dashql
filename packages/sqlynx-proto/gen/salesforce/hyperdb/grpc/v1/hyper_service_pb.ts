// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file salesforce/hyperdb/grpc/v1/hyper_service.proto (package salesforce.hyperdb.grpc.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Empty, Message, proto3 } from "@bufbuild/protobuf";

/**
 * QueryParam represents a query alongside with additional options to describe
 * the execution context, like attached databases or parameters. Additionally, the
 * output format for data chunks can be configured 
 *
 * @generated from message salesforce.hyperdb.grpc.v1.QueryParam
 */
export class QueryParam extends Message<QueryParam> {
  /**
   * The SQL query text.
   * See https://tableau.github.io/hyper-db/docs/sql/ for a documentation of Hyper's SQL.
   *
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * Specify the list of attached databases for this query
   *
   * @generated from field: repeated salesforce.hyperdb.grpc.v1.AttachedDatabase database = 2;
   */
  database: AttachedDatabase[] = [];

  /**
   * Specify the output format for query result data chunks. Default is text output.
   *
   * @generated from field: salesforce.hyperdb.grpc.v1.QueryParam.OutputFormat output_format = 3;
   */
  outputFormat = QueryParam_OutputFormat.TEXT_DEBUG;

  /**
   * Settings to allow adjusting the execution of a query.
   * See https://tableau.github.io/hyper-db/docs/hyper-api/connection#connection-settings
   *
   * @generated from field: map<string, string> params = 4;
   */
  params: { [key: string]: string } = {};

  constructor(data?: PartialMessage<QueryParam>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "salesforce.hyperdb.grpc.v1.QueryParam";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "database", kind: "message", T: AttachedDatabase, repeated: true },
    { no: 3, name: "output_format", kind: "enum", T: proto3.getEnumType(QueryParam_OutputFormat) },
    { no: 4, name: "params", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryParam {
    return new QueryParam().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryParam {
    return new QueryParam().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryParam {
    return new QueryParam().fromJsonString(jsonString, options);
  }

  static equals(a: QueryParam | PlainMessage<QueryParam> | undefined, b: QueryParam | PlainMessage<QueryParam> | undefined): boolean {
    return proto3.util.equals(QueryParam, a, b);
  }
}

/**
 * Currently supported output formats
 *
 * @generated from enum salesforce.hyperdb.grpc.v1.QueryParam.OutputFormat
 */
export enum QueryParam_OutputFormat {
  /**
   * Encode the result chunk in a text-based format intended for debugging gRPC on the command line.
   * Currently, this format is the same as `QUERY_SERVICE_V1`, which encodes the result as a JSON array.
   * However, this format might change in the future.
   *
   * @generated from enum value: TEXT_DEBUG = 0;
   */
  TEXT_DEBUG = 0,

  /**
   * Do not use this format when onboarding any new workloads. `ARROW_STREAM` is
   * strictly preferable.
   * Encode the result chunk in a proprietary variant similar to the "Arrow IPC format".
   * Each result chunk consists of a schema and a record batch message.
   * This is the original format of the gRPC proxy. For the JDBC Tableau connector, this
   * format is passed through directly to the public Data Cloud API endpoint. As such,
   * we cannot just drop support for it.
   *
   * @generated from enum value: ARROW_LEGACY = 2;
   */
  ARROW_LEGACY = 2,

  /**
   * Do not use this format when onboarding any new workloads. `ARROW_STREAM` is
   * strictly preferable.
   * Encode the result chunk as a JSON array of objects using the Query Service V1 SQL API convention.
   *
   * @generated from enum value: QUERY_SERVICE_V1 = 3;
   */
  QUERY_SERVICE_V1 = 3,

  /**
   * Encode the result chunk as part of a single Arrow IPC stream that encompasses all result chunks of a query.
   * This means only the first result chunk contains a schema message.
   * The following result chunks contain one or more record batch messages.
   *
   * @generated from enum value: ARROW_STREAM = 4;
   */
  ARROW_STREAM = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(QueryParam_OutputFormat)
proto3.util.setEnumType(QueryParam_OutputFormat, "salesforce.hyperdb.grpc.v1.QueryParam.OutputFormat", [
  { no: 0, name: "TEXT_DEBUG" },
  { no: 2, name: "ARROW_LEGACY" },
  { no: 3, name: "QUERY_SERVICE_V1" },
  { no: 4, name: "ARROW_STREAM" },
]);

/**
 * @generated from message salesforce.hyperdb.grpc.v1.AttachedDatabase
 */
export class AttachedDatabase extends Message<AttachedDatabase> {
  /**
   * Access path for the database
   *
   * @generated from field: string path = 1;
   */
  path = "";

  /**
   * Alias for the database under which it should be availabe in SQL
   *
   * @generated from field: string alias = 2;
   */
  alias = "";

  constructor(data?: PartialMessage<AttachedDatabase>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "salesforce.hyperdb.grpc.v1.AttachedDatabase";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "alias", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AttachedDatabase {
    return new AttachedDatabase().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AttachedDatabase {
    return new AttachedDatabase().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AttachedDatabase {
    return new AttachedDatabase().fromJsonString(jsonString, options);
  }

  static equals(a: AttachedDatabase | PlainMessage<AttachedDatabase> | undefined, b: AttachedDatabase | PlainMessage<AttachedDatabase> | undefined): boolean {
    return proto3.util.equals(AttachedDatabase, a, b);
  }
}

/**
 * The result of a query, in a QueryResult stream the result header will always
 * come first and will be followed by the configured result chunk type.
 *
 * @generated from message salesforce.hyperdb.grpc.v1.QueryResult
 */
export class QueryResult extends Message<QueryResult> {
  /**
   * @generated from oneof salesforce.hyperdb.grpc.v1.QueryResult.result
   */
  result: {
    /**
     * @generated from field: salesforce.hyperdb.grpc.v1.QueryResultHeader header = 1;
     */
    value: QueryResultHeader;
    case: "header";
  } | {
    /**
     * @generated from field: salesforce.hyperdb.grpc.v1.QueryBinaryResultChunk arrow_chunk = 4;
     */
    value: QueryBinaryResultChunk;
    case: "arrowChunk";
  } | {
    /**
     * @generated from field: salesforce.hyperdb.grpc.v1.QueryStringResultChunk qsv1_chunk = 5;
     */
    value: QueryStringResultChunk;
    case: "qsv1Chunk";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<QueryResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "salesforce.hyperdb.grpc.v1.QueryResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: QueryResultHeader, oneof: "result" },
    { no: 4, name: "arrow_chunk", kind: "message", T: QueryBinaryResultChunk, oneof: "result" },
    { no: 5, name: "qsv1_chunk", kind: "message", T: QueryStringResultChunk, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryResult {
    return new QueryResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryResult {
    return new QueryResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryResult {
    return new QueryResult().fromJsonString(jsonString, options);
  }

  static equals(a: QueryResult | PlainMessage<QueryResult> | undefined, b: QueryResult | PlainMessage<QueryResult> | undefined): boolean {
    return proto3.util.equals(QueryResult, a, b);
  }
}

/**
 * Describes the schema of the query result 
 *
 * @generated from message salesforce.hyperdb.grpc.v1.QueryResultHeader
 */
export class QueryResultHeader extends Message<QueryResultHeader> {
  /**
   * @generated from oneof salesforce.hyperdb.grpc.v1.QueryResultHeader.header
   */
  header: {
    /**
     * Returned for normal queries (i.e., SELECT)
     *
     * @generated from field: salesforce.hyperdb.grpc.v1.QueryResultSchema schema = 1;
     */
    value: QueryResultSchema;
    case: "schema";
  } | {
    /**
     * Returned when the query was of statement type
     *
     * @generated from field: salesforce.hyperdb.grpc.v1.QueryCommandOk command = 2;
     */
    value: QueryCommandOk;
    case: "command";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<QueryResultHeader>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "salesforce.hyperdb.grpc.v1.QueryResultHeader";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "message", T: QueryResultSchema, oneof: "header" },
    { no: 2, name: "command", kind: "message", T: QueryCommandOk, oneof: "header" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryResultHeader {
    return new QueryResultHeader().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryResultHeader {
    return new QueryResultHeader().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryResultHeader {
    return new QueryResultHeader().fromJsonString(jsonString, options);
  }

  static equals(a: QueryResultHeader | PlainMessage<QueryResultHeader> | undefined, b: QueryResultHeader | PlainMessage<QueryResultHeader> | undefined): boolean {
    return proto3.util.equals(QueryResultHeader, a, b);
  }
}

/**
 * Returned for statements, some statements additionally return the affected row count.
 * The server will only send this message once the changes of the statement are committed successfully. 
 *
 * @generated from message salesforce.hyperdb.grpc.v1.QueryCommandOk
 */
export class QueryCommandOk extends Message<QueryCommandOk> {
  /**
   * @generated from oneof salesforce.hyperdb.grpc.v1.QueryCommandOk.command_return
   */
  commandReturn: {
    /**
     * @generated from field: google.protobuf.Empty empty = 2;
     */
    value: Empty;
    case: "empty";
  } | {
    /**
     * @generated from field: uint64 affected_rows = 1;
     */
    value: bigint;
    case: "affectedRows";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<QueryCommandOk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "salesforce.hyperdb.grpc.v1.QueryCommandOk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "empty", kind: "message", T: Empty, oneof: "command_return" },
    { no: 1, name: "affected_rows", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "command_return" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryCommandOk {
    return new QueryCommandOk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryCommandOk {
    return new QueryCommandOk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryCommandOk {
    return new QueryCommandOk().fromJsonString(jsonString, options);
  }

  static equals(a: QueryCommandOk | PlainMessage<QueryCommandOk> | undefined, b: QueryCommandOk | PlainMessage<QueryCommandOk> | undefined): boolean {
    return proto3.util.equals(QueryCommandOk, a, b);
  }
}

/**
 * Schema of the query result 
 *
 * @generated from message salesforce.hyperdb.grpc.v1.QueryResultSchema
 */
export class QueryResultSchema extends Message<QueryResultSchema> {
  /**
   * @generated from field: repeated salesforce.hyperdb.grpc.v1.ColumnDescription column = 1;
   */
  column: ColumnDescription[] = [];

  constructor(data?: PartialMessage<QueryResultSchema>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "salesforce.hyperdb.grpc.v1.QueryResultSchema";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "column", kind: "message", T: ColumnDescription, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryResultSchema {
    return new QueryResultSchema().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryResultSchema {
    return new QueryResultSchema().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryResultSchema {
    return new QueryResultSchema().fromJsonString(jsonString, options);
  }

  static equals(a: QueryResultSchema | PlainMessage<QueryResultSchema> | undefined, b: QueryResultSchema | PlainMessage<QueryResultSchema> | undefined): boolean {
    return proto3.util.equals(QueryResultSchema, a, b);
  }
}

/**
 * Describes a column 
 *
 * @generated from message salesforce.hyperdb.grpc.v1.ColumnDescription
 */
export class ColumnDescription extends Message<ColumnDescription> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: salesforce.hyperdb.grpc.v1.SqlType type = 2;
   */
  type?: SqlType;

  constructor(data?: PartialMessage<ColumnDescription>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "salesforce.hyperdb.grpc.v1.ColumnDescription";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "message", T: SqlType },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ColumnDescription {
    return new ColumnDescription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ColumnDescription {
    return new ColumnDescription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ColumnDescription {
    return new ColumnDescription().fromJsonString(jsonString, options);
  }

  static equals(a: ColumnDescription | PlainMessage<ColumnDescription> | undefined, b: ColumnDescription | PlainMessage<ColumnDescription> | undefined): boolean {
    return proto3.util.equals(ColumnDescription, a, b);
  }
}

/**
 * Type of a result column, provides additional information through the modifier field 
 *
 * @generated from message salesforce.hyperdb.grpc.v1.SqlType
 */
export class SqlType extends Message<SqlType> {
  /**
   * Matches hyperapi::SqlType enum
   *
   * @generated from field: salesforce.hyperdb.grpc.v1.SqlType.TypeTag tag = 1;
   */
  tag = SqlType_TypeTag.HYPER_UNSUPPORTED;

  /**
   * Additional type information, e.g. about precision
   *
   * @generated from oneof salesforce.hyperdb.grpc.v1.SqlType.modifier
   */
  modifier: {
    /**
     * @generated from field: google.protobuf.Empty empty = 2;
     */
    value: Empty;
    case: "empty";
  } | {
    /**
     * Only available if tag is a text type
     *
     * @generated from field: uint32 max_length = 3;
     */
    value: number;
    case: "maxLength";
  } | {
    /**
     * Only available if tag is a numeric type
     *
     * @generated from field: salesforce.hyperdb.grpc.v1.SqlType.NumericModifier numeric_modifier = 4;
     */
    value: SqlType_NumericModifier;
    case: "numericModifier";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SqlType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "salesforce.hyperdb.grpc.v1.SqlType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tag", kind: "enum", T: proto3.getEnumType(SqlType_TypeTag) },
    { no: 2, name: "empty", kind: "message", T: Empty, oneof: "modifier" },
    { no: 3, name: "max_length", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "modifier" },
    { no: 4, name: "numeric_modifier", kind: "message", T: SqlType_NumericModifier, oneof: "modifier" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SqlType {
    return new SqlType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SqlType {
    return new SqlType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SqlType {
    return new SqlType().fromJsonString(jsonString, options);
  }

  static equals(a: SqlType | PlainMessage<SqlType> | undefined, b: SqlType | PlainMessage<SqlType> | undefined): boolean {
    return proto3.util.equals(SqlType, a, b);
  }
}

/**
 * @generated from enum salesforce.hyperdb.grpc.v1.SqlType.TypeTag
 */
export enum SqlType_TypeTag {
  /**
   * @generated from enum value: HYPER_UNSUPPORTED = 0;
   */
  HYPER_UNSUPPORTED = 0,

  /**
   * @generated from enum value: HYPER_BOOL = 1;
   */
  HYPER_BOOL = 1,

  /**
   * @generated from enum value: HYPER_BIG_INT = 2;
   */
  HYPER_BIG_INT = 2,

  /**
   * @generated from enum value: HYPER_SMALL_INT = 3;
   */
  HYPER_SMALL_INT = 3,

  /**
   * @generated from enum value: HYPER_INT = 4;
   */
  HYPER_INT = 4,

  /**
   * @generated from enum value: HYPER_NUMERIC = 5;
   */
  HYPER_NUMERIC = 5,

  /**
   * @generated from enum value: HYPER_DOUBLE = 6;
   */
  HYPER_DOUBLE = 6,

  /**
   * @generated from enum value: HYPER_OID = 7;
   */
  HYPER_OID = 7,

  /**
   * @generated from enum value: HYPER_BYTE_A = 8;
   */
  HYPER_BYTE_A = 8,

  /**
   * @generated from enum value: HYPER_TEXT = 9;
   */
  HYPER_TEXT = 9,

  /**
   * @generated from enum value: HYPER_VARCHAR = 10;
   */
  HYPER_VARCHAR = 10,

  /**
   * @generated from enum value: HYPER_CHAR = 11;
   */
  HYPER_CHAR = 11,

  /**
   * @generated from enum value: HYPER_JSON = 12;
   */
  HYPER_JSON = 12,

  /**
   * @generated from enum value: HYPER_DATE = 13;
   */
  HYPER_DATE = 13,

  /**
   * @generated from enum value: HYPER_INTERVAL = 14;
   */
  HYPER_INTERVAL = 14,

  /**
   * @generated from enum value: HYPER_TIME = 15;
   */
  HYPER_TIME = 15,

  /**
   * @generated from enum value: HYPER_TIMESTAMP = 16;
   */
  HYPER_TIMESTAMP = 16,

  /**
   * @generated from enum value: HYPER_TIMESTAMP_TZ = 17;
   */
  HYPER_TIMESTAMP_TZ = 17,

  /**
   * @generated from enum value: HYPER_GEOGRAPHY = 18;
   */
  HYPER_GEOGRAPHY = 18,
}
// Retrieve enum metadata with: proto3.getEnumType(SqlType_TypeTag)
proto3.util.setEnumType(SqlType_TypeTag, "salesforce.hyperdb.grpc.v1.SqlType.TypeTag", [
  { no: 0, name: "HYPER_UNSUPPORTED" },
  { no: 1, name: "HYPER_BOOL" },
  { no: 2, name: "HYPER_BIG_INT" },
  { no: 3, name: "HYPER_SMALL_INT" },
  { no: 4, name: "HYPER_INT" },
  { no: 5, name: "HYPER_NUMERIC" },
  { no: 6, name: "HYPER_DOUBLE" },
  { no: 7, name: "HYPER_OID" },
  { no: 8, name: "HYPER_BYTE_A" },
  { no: 9, name: "HYPER_TEXT" },
  { no: 10, name: "HYPER_VARCHAR" },
  { no: 11, name: "HYPER_CHAR" },
  { no: 12, name: "HYPER_JSON" },
  { no: 13, name: "HYPER_DATE" },
  { no: 14, name: "HYPER_INTERVAL" },
  { no: 15, name: "HYPER_TIME" },
  { no: 16, name: "HYPER_TIMESTAMP" },
  { no: 17, name: "HYPER_TIMESTAMP_TZ" },
  { no: 18, name: "HYPER_GEOGRAPHY" },
]);

/**
 * The precision of a numeric column
 *
 * @generated from message salesforce.hyperdb.grpc.v1.SqlType.NumericModifier
 */
export class SqlType_NumericModifier extends Message<SqlType_NumericModifier> {
  /**
   * @generated from field: uint32 precision = 1;
   */
  precision = 0;

  /**
   * @generated from field: uint32 scale = 2;
   */
  scale = 0;

  constructor(data?: PartialMessage<SqlType_NumericModifier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "salesforce.hyperdb.grpc.v1.SqlType.NumericModifier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "precision", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "scale", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SqlType_NumericModifier {
    return new SqlType_NumericModifier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SqlType_NumericModifier {
    return new SqlType_NumericModifier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SqlType_NumericModifier {
    return new SqlType_NumericModifier().fromJsonString(jsonString, options);
  }

  static equals(a: SqlType_NumericModifier | PlainMessage<SqlType_NumericModifier> | undefined, b: SqlType_NumericModifier | PlainMessage<SqlType_NumericModifier> | undefined): boolean {
    return proto3.util.equals(SqlType_NumericModifier, a, b);
  }
}

/**
 * A result chunk which contains multiple rows encoded in the binary format requested via the `output_format` field of
 * the `QueryParam` message 
 *
 * @generated from message salesforce.hyperdb.grpc.v1.QueryBinaryResultChunk
 */
export class QueryBinaryResultChunk extends Message<QueryBinaryResultChunk> {
  /**
   * @generated from field: bytes data = 127;
   */
  data = new Uint8Array(0);

  constructor(data?: PartialMessage<QueryBinaryResultChunk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "salesforce.hyperdb.grpc.v1.QueryBinaryResultChunk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 127, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBinaryResultChunk {
    return new QueryBinaryResultChunk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBinaryResultChunk {
    return new QueryBinaryResultChunk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBinaryResultChunk {
    return new QueryBinaryResultChunk().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBinaryResultChunk | PlainMessage<QueryBinaryResultChunk> | undefined, b: QueryBinaryResultChunk | PlainMessage<QueryBinaryResultChunk> | undefined): boolean {
    return proto3.util.equals(QueryBinaryResultChunk, a, b);
  }
}

/**
 * A result chunk which contains multiple rows encoded in the textual format requested via the `output_format` field of
 * the `QueryParam` message 
 *
 * @generated from message salesforce.hyperdb.grpc.v1.QueryStringResultChunk
 */
export class QueryStringResultChunk extends Message<QueryStringResultChunk> {
  /**
   * @generated from field: string data = 127;
   */
  data = "";

  constructor(data?: PartialMessage<QueryStringResultChunk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "salesforce.hyperdb.grpc.v1.QueryStringResultChunk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 127, name: "data", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryStringResultChunk {
    return new QueryStringResultChunk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryStringResultChunk {
    return new QueryStringResultChunk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryStringResultChunk {
    return new QueryStringResultChunk().fromJsonString(jsonString, options);
  }

  static equals(a: QueryStringResultChunk | PlainMessage<QueryStringResultChunk> | undefined, b: QueryStringResultChunk | PlainMessage<QueryStringResultChunk> | undefined): boolean {
    return proto3.util.equals(QueryStringResultChunk, a, b);
  }
}

